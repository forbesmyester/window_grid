#!/bin/bash 

# Window-grid 
# 
# This script provides tiling-like capabilities for any window-manager.
# 
# This script positions an X11 window based on a grid. 
# The grid is subdivided, by default, into 8 segments in 
# each direction. (This can be overridden using the -d flag.)
#
# Position and size are specified in grid-units and can be relative.
# for example, the options -x 1 -y 1 will place the top-left of the
# window 1 grid unit down, and 1 grid-unit right of the top-left of
# the screen.  You can also use -x +1 or -x -1 to move the window
# one grid unit to the right or left respectively.
# 
# Height and width are specified the same way and can also be relative
# so if you specify -w +1, the window will be made one grid-unit larger
# than it currently is.  The minimum size of a window is 1 grid-unit
# in each-direction.  The maximum is the size of the entire screen.
# 
# Note that the actual pixel-size of a grid segment will depend on the
# your screen size.  For example, for a 1920x1080 display, the default
# size of a 1x1 grid segment is 240 x 135. 
# 
# This script is screen-aware and divides each monitor according to 
# the resolution of that monitor. It can place windows on multiple 
# screens, and works in most 'normal' multi-monitor setups,
# but note that it currently does not create windows larger than the 
# screen the window starts on. Note also that when choosing sizes and 
# positions, the grid size used is based on the monitor the window 
# starts on. So in configurations where resolution is different, 
# the grid may not line up the way you want. Because of this, if 
# you wish to move windows between displays, it's best to use 
# your window manager (or another tool) to move them to the 
# display you want them on before invoking this script to do 
# grid-positioning. This functionality may be added in a future 
# version.

VERSION=1.0
SCREEN=0
DIVISIONS=8
CLOSEST_SIZE=0
CLOSEST_POS=0

function display_help() 
{
    NAME=$1
    echo "window-grid v. $VERSION"
    echo ""
    echo "Usage: $NAME [args]"
    echo ""
    echo "Args:"
    echo ""
    echo "  -i WINDOW_ID     - Act on window ID provided"
    echo "                     (defaults to active window)"
    echo "  -s SCREEN        - Act on screen provided"
    echo "  -d DIVISIONS     - Number of squares screen "
    echo "                     should be divided into"
    echo "  -w WIDTH         - new window width (in grid-squares)"
    echo "  -h HEIGHT        - new window height (in grid-squares)"
    echo "  -x XPOS          - new left position (in grid-squares)"
    echo "  -y YPOS          - new top position (in grid-squares)"
    echo "  -c size|pos|both - Fit window to closest grid space "
    echo "                     using size, position, or both"

}

while getopts c:i:s:w:h:x:y:d:? FLAG; do
    ARGS=1;
    case $FLAG in
        c)
            if [ $OPTARG == "size" -o $OPTARG == "both" ]; then
                        CLOSEST_SIZE=1;
            fi
            if [ $OPTARG == "pos" -o $OPTARG == "both" ]; then
                        CLOSEST_POS=1;
            fi
            ;;
        i)
            WINDOW=$OPTARG
            ;;
        s)
            SCREEN=$OPTARG
            ;;
        d) 
            DIVISIONS=$OPTARG
            ;;
        w)
            NEW_WIDTH=$OPTARG
            ;;
        h)
            NEW_HEIGHT=$OPTARG
            ;;
        x)
            NEW_XPOS=$OPTARG
            ;;
        y)
            NEW_YPOS=$OPTARG
            ;;
        ?)
            display_help $0
            ;;
    esac
done    

if [ "${ARGS}x" == "x" ]; then 
    display_help $0
    exit
fi

if [ "${WINDOW}x" == "x" ]; then
    WINDOW=$(xdotool getactivewindow)
fi

function get_screen_info() 
{
    SCREEN=$1
    eval $(xdotool getdisplaygeometry --shell|awk '{ print  "local " $1}')
    SEGMENT_WIDTH=$(( $WIDTH / $DIVISIONS ))
    SEGMENT_HEIGHT=$(( $HEIGHT / $DIVISIONS ))
    eval $(echo SCREEN${SCREEN}_WIDTH=${WIDTH})
    eval $(echo SCREEN${SCREEN}_HEIGHT=${HEIGHT})
    eval $(echo SCREEN${SCREEN}_SEGMENTX=${SEGMENT_WIDTH})
    eval $(echo SCREEN${SCREEN}_SEGMENTY=${SEGMENT_HEIGHT})
}

get_screen_info $SCREEN

function get_closest() {
    local segment=$1
    local size=$2

    local half=$(( $segment / 2 ))
    local closest=$(( (( $size + $half ) / $segment) * $segment ))

    echo $closest
}

function safe_size() {
    local size=$1
    local minimum=0
    if [ -z "$2" ]; then
       minimum=0
    else 
       minimum=$2
    fi

    if [ $size -le 0 ]; then
        size=$minimum;
    fi
    echo $size
}

function set_size() {
    local window=$1
    local X=$2
    local Y=$3
    local W=$4
    local H=$5
    local frame_width=0
    local frame_height=0

    local frame=$(xprop -id $window|grep _NET_FRAME_EXTENTS |awk -F[=,] '{print $2, $3}')
    if [ "x${frame}" != "x" ]; then 
        frame_width=$(echo $frame|cut -d ' ' -f 1)
        frame_height=$(echo $frame|cut -d ' ' -f 2)
    fi

    NEW_X=$( safe_size $(( $X - $frame_width )) )
    NEW_Y=$( safe_size $(( $Y - $frame_height )) )
    NEW_W=$( safe_size $W 1 )
    NEW_H=$( safe_size $H 1 )

    local has_max=$(xprop '_NET_WM_STATE' -id $window|grep MAXIMIZED)

    if [ "${has_max}" != "" ]; then 
        wmctrl -ir $window -b remove,maximized_vert,maximized_horz 
    fi

    wmctrl -ir $window -e 0,${NEW_X},${NEW_Y},${NEW_W},${NEW_H}
}
# get_closest $SCREEN0_SEGMENTX

function handle_offset()
{
    local CHANGE=$1
    local CURRENT=$2
    local SEGMENT_SIZE=$3
    local NEW_VAL

    if [ $(expr ${CHANGE} : '^+') == "1" ]; then
        NEW_VAL=$(( ($CURRENT + $(echo $CHANGE | sed s/^+//)) * $SEGMENT_SIZE ))
    elif [ $(expr ${CHANGE} : '^-') == "1" ]; then
        NEW_VAL=$(( ($CURRENT - $(echo $CHANGE | sed s/^-//) ) * $SEGMENT_SIZE ))
    else
        NEW_VAL=$(( $SEGMENT_SIZE * $CHANGE ))
    fi
    echo $NEW_VAL
}

# set our geometry from window
eval $(xdotool getwindowgeometry --shell $WINDOW)
#frame=$(xprop _NET_FRAME_EXTENTS -id $WINDOW|awk -F[=,] '{print $2, $3}')
#frame_width=$(echo $frame|cut -d ' ' -f 1)
#frame_height=$(echo $frame|cut -d ' ' -f 2)
# current positions in terms of grid
CURRENT_X=$(( $(get_closest $SEGMENT_WIDTH $X) / $SEGMENT_WIDTH ))
CURRENT_Y=$(( $(get_closest $SEGMENT_HEIGHT $Y) / $SEGMENT_HEIGHT ))
CURRENT_W=$(( $(get_closest $SEGMENT_WIDTH $WIDTH) / $SEGMENT_WIDTH ))
CURRENT_H=$(( $(get_closest $SEGMENT_HEIGHT $HEIGHT) / $SEGMENT_HEIGHT ))
        
if [ $CLOSEST_POS == "1" ]; then
    NEW_X=$(get_closest $SEGMENT_WIDTH $X)
    NEW_Y=$(get_closest $SEGMENT_HEIGHT $Y)
fi

if [ $CLOSEST_SIZE == "1" ]; then
    NEW_W=$(get_closest $SEGMENT_WIDTH $WIDTH)
    NEW_H=$(get_closest $SEGMENT_HEIGHT $HEIGHT)
fi

if [ "${NEW_X}x" == "x" ]; then
    NEW_X=$X
fi
if [ "${NEW_Y}x" == "x" ]; then
    NEW_Y=$Y
fi
if [ "${NEW_W}x" == "x" ]; then
    NEW_W=$WIDTH
fi
if [ "${NEW_H}x" == "x" ]; then
    NEW_H=$HEIGHT
fi
if [ "${NEW_XPOS}x" != "x" ]; then
    NEW_X=$(handle_offset $NEW_XPOS $CURRENT_X $SEGMENT_WIDTH)

fi
if [ "${NEW_YPOS}x" != "x" ]; then
    NEW_Y=$(handle_offset $NEW_YPOS $CURRENT_Y $SEGMENT_HEIGHT)
fi
if [ "${NEW_WIDTH}x" != "x" ]; then
    NEW_W=$(safe_size $(handle_offset $NEW_WIDTH $CURRENT_W $SEGMENT_WIDTH) $SEGMENT_WIDTH)
fi
if [ "${NEW_HEIGHT}x" != "x" ]; then
    NEW_H=$(safe_size $(handle_offset $NEW_HEIGHT $CURRENT_H $SEGMENT_HEIGHT) $SEGMENT_HEIGHT)
fi

set_size $WINDOW $NEW_X $NEW_Y $NEW_W $NEW_H

